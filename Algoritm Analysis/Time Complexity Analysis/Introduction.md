-----
### 알고리즘의 시간 복잡도 분석 - 도입
-----
1. 빠른 알고리즘을 만들기 위해 가장 먼저 해야할 것은 알고리즘의 속도 측정
    - 알고리즘의 속도를 비교하는 가장 직관적인 방법 : 각 프로그램을 구현한 뒤, 입력에 대한 프로그램의 수행 시간을 측정
    - 하지만 이는 프로그램의 수행 시간은 사용한 프로그래밍 언어, 하드웨어, 운영체제, 컴파일러까지 수 많은 요소에 의해 변경 가능
    - 또한, 프로그램의 실제 수행 시간이 다양한 입력에 대한 실행 시간을 반영하지 못함
    - 알고리즘은 언제나 같은 속도로 작동하는 것이 아닌, 입력의 크기나 특성에 따라 수행 시간이 달라질 수 있음

2. 알고리즘의 수행 시간 측정 기준 : 반복문
    - 입력에 상관 없이 항상 같은 수행 시간을 가지는 알고리즘도 있지만, 대개 입력의 크기에 따라 수행 횟수가 정해지는 반복문이 존재
    - 입력의 크기가 작을 때는 반복 외에 다른 부분들이 갖는 비중이 클 수 있지만, 입력의 크기가 커지면 커질수록, 반복문이 알고리즘 수행 시간을 지배
    - 대개 알고리즘의 수행 시간을 반복문이 수행되는 횟수로 측정되므로, 반복문의 수행 횟수는 입력의 크기에 대한 함수로 표현
    - 예시 : 주어진 배열에서 가장 많이 등장하는 수
```java
package algorithm;

// 주어진 배열에서 가장 많이 등장하는 숫자 반환
public class MaxValue {
    // 주어진 배열 A에서 가장 많이 등장하는 숫자를 반환 (만약, 두 가지 이상이면 아무것이나 반환)
    int majority1(int[] A) {
        int n = A.length; // A 배열의 크기
        int majority = -1; // 가장 많이 등장하는 수
        int majorityCount = 0; // 가장 많이 등장한 수의 등장 횟수

        for(int i = 0; i < n; i++) {
            // A에 등장하는 A[i]의 수를 셈

            int v = A[i];
            int count = 0;

            for (int j = 0; j < n; j++) {
                if (A[j] == v) { // A[i]의 수를 세는 부분
                    ++count;
                }
            }


            // 지금까지 본 최대 빈도보다 많이 출현했으면, 답 갱신
            if (count > majorityCount) {
                majority = count;
                majority = v;
            }
        }
        return majorityCount;
    }
}
```
  - 숫자의 범위가 작다면 배열을 이용해 각 숫자가 등장하는 횟수를 쉽게 셀 수 있으며, 마지막에 빈도수 배열을 순회하면서 최대치의 위치를 찾으면 됨
```java
// A의 각 원소가 0부터 100 사이의 값일 경우 가장 많이 등장하는 수를 반환
public class MaxValue2 {
    int majority2(int[] A) {
        int n = A.length;

        int[] countA = new int[n + 1]; // 0부터 100 사이의 값이 등장한 횟수를 저장할 배열

        for(int i = 0; i <= n; i++) {
            countA[A[i]]++; // 0부터 100 사이의 값에 대해 등장 횟수 저장
        }

        // 지금까지 확인한 숫자 중 가장 빈도수가 큰 것을 majority에 저장
        int majority = 0;

        for(int i = 1; i <= 100; i++) {
            if(countA[i] > countA[majority]) { // 가장 높은 빈도수를 가진 값을 가진 수보다 큰 수가 존재
                majority = i; // 변경
            }
        }

        return majority;
    }
}
```
   - 이 코드에는 반복문이 2개 존재하는데, 하나는 $N$번 수행, 다른 하나는 100번 수행되므로 전체 반복문 수행 횟수 : $N + 100$
   - 그런데 $N$이 커질수록, 반복문의 수행 시간에서 100번은 차지하는 비중이 줄어듬
   - 따라서, 궁극적으로 이 알고리즘의 수행 시간은 $N$
