-----
### 시간 복잡도 활용하기
-----
1. 알고리즘 선택 기준으로 사용하기
   - 버블 정렬과 병합 정렬의 시간 복잡도 : O($n^{2}$), O(n log n)

2. 예) 수 정렬하기
   - 문제 : N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성
   - 입력 : 1번쨰 줄에 개수 N(1 ≤ N ≤ 1,000,000), 2번째 줄부터는 N개의 줄에 숫자가 주어지며, 이 수는 절댓값이 1,000,000봐 작거나 같은 정수로, 수는 중복되지 않음
   - 출력 : 1번쨰 줄부터 N개의 줄에 오름차순 정렬한 결과를 1줄에 1개씩 출력
<div align="center">
<img src="https://github.com/user-attachments/assets/f3e681e0-823e-4c6e-b9a6-e2af8345a932">
</div>

   - 시간 제한이 2초이므로, 이 조건을 만족하려면 2억 번 이하의 연산 횟수로 문제를 해결해야 함
   - 따라서, 문제에 주어진 시간 제한과 데이터 크기를 바탕으로 어떤 정렬 알고리즘을 사용해야 할 것인지 판단할 수 있음
     + 연산 횟수는 1초에 1억 번 연산하는 것을 기준으로 생각
     + 시간 복잡도는 항상 최악일 때, 즉, 데이터 크기가 가장 클 때를 기준으로 함

3. 연산 횟수 계산 방법 : 연산 횟수 = 알고리즘 시간 복잡도 n 값에 데이터 최대 크기를 대입하여 도출
4. 알고리즘 적합성 평가
   - 버블 정렬 = $(1,000,000)^{2}$ = 1,000,000,000,000 > 200,000,000 → 부적합 알고리즘
   - 병합 정렬 = 1,000,000 log(1,000,000) = 약 20,000,000 < 200,000,000 → 적합 알고리즘
   - 문제에 주어진 시간 제한이 2초 이므로 연산 횟수 2억 번 안에 원하는 답을 구해야 하며, 버블 정렬은 약 10억 번의 연산 횟수가 필요하므로 적합한 알고리즘이 아니며, 병합 정렬은 약 2,000만 번의 연사 횟수로 답을 구할 수 있으므로 문제 풀기 적합한 알고리즘으로 판단 가능
   - 이와 같이 시간 복잡도 분석으로 문제에서 사용할 수 있는 알고리즘을 선택할 수 있고, 이 범위를 바탕으로 문제의 실마리를 찾을 수 있음 = 즉, 데이터 크기(N)를 단서로 사용해야 하는 알고리즘 추측 가능

5. 시간 복잡도를 바탕으로 코드 로직 개선하기
   - 시간 복잡도는 작성한 코드의 비효율적인 로직(Logic)을 개선하는 바탕으로도 사용 가능
     + 이 부분을 활용하려면 가장 먼저 코드의 시간 복잡도를 도출할 수 있어야 함

   - 시간 복잡도 도출 기준
     + 상수는 시간 복잡도 계산에서 제외
     + 가장 많이 중첩된 반복문의 수행 횟수가 시간 복잡도의 기준이 됨

6. 코드 예
   - 연산 횟수 == N
```java
package time_complexity;

public class timeComplexityExample2 {
    public static void main(String[] args) {
        int N = 100000;
        int cnt = 0;
        
        for (int i = 0; i < N; i++) {
            System.out.println("연산 횟수 : " + cnt++);
        }
    }
}
```

   - 연산 횟수 == 3N
```java
package time_complexity;

public class timeComplexityExample2 {
    public static void main(String[] args) {
        int N = 100000;
        int cnt = 0;

        for (int i = 0; i < N; i++) {
            System.out.println("연산 횟수 : " + cnt++);
        }

        for (int i = 0; i < N; i++) {
            System.out.println("연산 횟수 : " + cnt++);
        }

        for (int i = 0; i < N; i++) {
            System.out.println("연산 횟수 : " + cnt++);
        }
    }
}
```

   - 두 예제 코드의 연산 횟수는 3배 차이 발생 : 코딩 테스트에서는 일반적으로 상수를 무시하므로 두 코드 모두 시간 복잡도는 O(n)으로 동일

   - 연산 횟수 == $N^{2}$
```java
package time_complexity;

public class timeComplexityExample4 {
    public static void main(String[] args) {
        int N = 100000;
        int cnt = 0;

        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                System.out.println("연산 횟수 : " + cnt++);
            }
        }
    }
}
```
   - 시간 복잡도는 가장 많이 중첩된 반복문을 기준으로 도출하므로 이 코드에서 이중 for문이 전체 코드의 시간 복잡도 기준이 됨
     + 만약 일반 for문이 10개 더 있다 하더라도 시간 복잡도는 변화 없이 $N^{2}$

   - 이와 같이 작성한 코드의 시간 복잡도를 도출할 수 있다면, 실제 코딩 테스트에서 시간 초과가 발생했을 때 문제가 되는 코드 도출 가능 및 해당 부분을 연산에 더욱 효율적 구조로 수정하는 작업으로 문제 해결 가능
