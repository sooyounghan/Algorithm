-----
### 최소 공통 조상
-----
1. 트리 그래프에서 임의의 두 노드를 선택했을 때, 두 노드가 각각 자신을 포함해 거슬러 올라가면서 부모 노드를 탐색할 때 처음 공통으로 만나게 되는 부모 노드를 의미
2. 일반적인 최소 공통 조상 구하기
   - 트리의 높이가 크지 않을 때 : 예) 같은 트리에서 4번, 15번 노드의 최소 공통 조상 - 먼저 루트 노드에서 탐색을 시작해 각 노드의 부모 노드의 깊이 저장
<div align="center">
<img src="https://github.com/user-attachments/assets/75e618e7-a921-4ad1-82dd-f66f4f278e66">
</div>

   - 선택된 두 노드의 깊이가 다른 경우 : 더 깊은 노드를 부모 노드로 1개씩 올려주면서, 같은 깊이로 맞추며, 이 때 두 노드가 같으면 최소 공통 조상이므로 탐색 종료
<div align="center">
<img src="https://github.com/user-attachments/assets/88eeb2ed-70cb-4cf1-9875-d77fcf717e6a">
</div>

   - 깊이가 같은 상태 : 동시에 부모 노드를 올라가면서 두 노드가 같은 노드가 될 때까지 반복 - 이 때, 처음 만나는 노드가 최소 공통 조상이 됨 (이 원리에 따라 다음 트리에서 4, 15번 트리의 최소 공통 부모는 1)
<div align="center">
<img src="https://github.com/user-attachments/assets/7f9d9841-c4d6-40a1-96ff-3c0b55e97196">
</div>

   - 위와 같은 방식을 이용하면 최소 공통 조상을 구할 수 있지만, 트리의 높이가 커질 경우 시간 제약 문제가 발생
   - 이를 해결하기 위해 새로 제안된 방식이 '최소 공통 조상 바르게 구하기' : 일반적인 최소 공통 조상 구하기 알고리즘을 약간 변형한 형태

3. 최소 공통 조상 빠르게 구하기
   - 핵심 : 서로의 깊이를 맞춰주거나 같아지는 노드를 찾을 때, 기존의 한 단계씩 올려주는 방식에서 $2^{K}$씩 올라가 비교하는 방식
   - 따라서, 기존에 자신의 부모 노드만 저장해 놓았던 방식에서 $2^{K}$번쨰 위치의 부모 노드까지 저장해 둬야 함
   - 부모 노드 저장 배열 만들기
     + 부모 노드 배열을 만들기 위해서는 이 배열의 정의와 점화식 정의
<div align="center">
<img src="https://github.com/user-attachments/assets/8a2cfe5f-eec5-47a6-b444-879a55bd60e3">
</div>

<div align="center">
<img src="https://github.com/user-attachments/assets/8a1ee2f0-0c9f-4317-ad3c-b1d6fcae0d51">
</div>

   - 점화식에서 N의 $2^{K}$번쨰 부모 노드 : N의 $2^{K-1}$번쨰 부모 노드의 $2^{K-1}$번째 부모 노드라는 의미
     + 즉, K = 4라고 가정하면, N의 16번쨰 부모 노드는 N의 8번째 부모 노드의 8번쨰 부모 노드

   - 배열에서 K는 '트리의 깊이 > $2^{K}'를 만족하는 최댓값
     + 트리에서 최대 깊이는 5이기 때문에, K = 2가 됨
     + 즉, 이 트리의 모든 노드는 $2^{3}$번쨰 부모 노드를 지니고 있는 경우가 없음
<div align="center">
<img src="https://github.com/user-attachments/assets/f9878b8d-c969-4b4c-9018-3a527ea2a89e">
</div>

   - 부모 노드의 배열의 점화식을 이용해 배열의 값 저장
<div align="center">
<img src="https://github.com/user-attachments/assets/d52a506f-00c3-4472-914b-b7e7647e741f">
</div>

   - 초기화된 배열을 바탕으로 K를 1개씩 증가시키면서, 나머지 배열을 채움
   - 예) 14의 $2^{2}$번째, 즉, 4번째 부모 노드(P[2][14])
<div align="center">
<img src="https://github.com/user-attachments/assets/d826686b-0ad2-4307-b266-5315f4049b7f">
</div>

   - 선택된 두 노드의 깊이 맞추기
     + P 배열을 이용해 기존에 한 단계씩 맞췄던 깊이를 $2^{K}$ 단위로 넘어가면서 맞춤
     + 예를 들어, 노드 2와 노드 15의 깊이를 맞추기
       * 노드 2의 깊이는 1, 노드 15의 깊이는 5로 두 노드의 깊이 차는 4
       * 깊이를 맞추기 위해 더 깊이 있는 노드 15의 4번쨰 부모 노드 P 배열을 찾으면, 4 = $2^{2}$이므로 K = 2이고, P[2][15] = 3이므로 노드 3으로 이동하면 노드 2와 높이를 맞추게 됨
     + 만약 높이 차가 20이라고 가정하면 $2^{K}$ ≤ 20을 만족하면서, K가 최대가 되는 만큼 이동하면서 높이 차가 0이 될 때까지 반복 : 즉, 높이 차가 20일 경우에는 $2^{4}$(16) → $2^{2}$(4)와 같이 두 번 이동

   - 최소 공통 조상 찾기
     + 공통 조상 찾는 작업 역시 한 단계씩이 아닌 $2^{K}$ 단위로 이동 : K값을 1씩 감소하면서 P 배열을 이용해 최초로 두 노드의 부모가 달라지는 값을 찾음
<div align="center">
<img src="https://github.com/user-attachments/assets/06353bec-acb1-4e21-b302-bebf43a2022b">
<img src="https://github.com/user-attachments/assets/754fa446-d606-419c-a108-05cfd0056158">
</div>

   - 최초로 달라지는 K에 대한 두 노드의 부모 노드를 찾아 이동
     + 즉, 노드 10, 노드 11로 이동
     + 이를 K가 0이 될때까지 반복 : 반복문이 종료된 후 이동한 2개의 노드가 같은 노드라면 해당 노드가, 다른 노드라면 바로 위의 부모 노드가 최소 공통 조상이 됨
     + 여기에서는 노드 10, 11이 서로 다른 노드이므로 바로 위 노드를 뜻하는 P[0][10] 또는 P[0][11], 즉 노드 6이 최소 공통 조상
<div align="center">
<img src="https://github.com/user-attachments/assets/f41bb019-4283-448e-b621-97d14e25b910">
</div>
