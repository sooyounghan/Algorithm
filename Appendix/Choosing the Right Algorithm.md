-----
### 알맞은 알고리즘 선택하기
-----
1. 코딩 테스트에서 풀이 알고리즘을 선택하는 것은 마치 여러 갈림길 앞에서 길을 선택하는 것
   - 코딩 테스트에서는 제한 시간이 있어서 일단 한 가지 알고리즘으로 구현을 시작하면, 그 선택이 잘못되었음을 알아도 처음부터 다시 풀기 쉽지 않음

2. 예제) 가장 짧은 부분합 구하기
```
N개의 숫자로 이루어진 수열이 있다.
각 숫자는 100이하 자연수다.
이 떄, 해당 수열의 연속된 부분합 중에서 그 합이 100을 넘는 가장 짧은 구간의 길이를 구하시오.
```

  - 입력
    + 1번째 줄에 수열의 길이를 나타내는 N(0 < N < 100,000)이 주어짐
    + 2번째 줄부터는 수열의 데이터인 배열 A의 값이 주어짐

  - 출력 : 가장 짧은 구간의 길이를 출력
<div align="center">
<img src="https://github.com/user-attachments/assets/f7390f09-0daa-447a-937a-b09b0e43ca4e">
</div>

   - 문제의 제목이 부분합을 구하는 것이고 설명에서도 부분합을 언급
<div align="center">
<img src="https://github.com/user-attachments/assets/e2a717d6-a1b4-489e-a68a-0342cf76c289">
</div>

   - 부분합 S[i]는 배열 A의 0 ~ i번째까지의 값의 합을 나타냄 : i ~ j 구간의 연속된 부분합은 S[j] ~ S[i - 1]이라는 수식으로 쉽게 구할 수 있음
   - 연속된 부분합 중 그 합이 100을 넘는 가장 짧은 구간을 구하라고 요구
   - '짧은 구간을 구해야 하는 것이니, 길이가 1인 것부터 점점 늘려가면서 모든 구간 합을 구해야 하는가?' : 이 방식을 비효율적이며, 문제에서 의도한 풀이 밥ㅇ식이 아님
   - 사실, 이 문제는 투 포인터 알고리즘을 이용하면 효율적 해결 가능
<div align="center">
<img src="https://github.com/user-attachments/assets/55196219-bab6-4245-b6dc-6fd2c00e9d53">
</div>

3. 이처럼 문제의 제목이나 지문 일부에만 집착해 알고리즘을 섣불리 선택하면, 풀이 방향이 엇나가 낭패를 볼 수 있음
   - 따라서, 문제를 분석한 뒤에는 자신이 선택한 알고리즘의 풀이 방식이 문제의 모든 조건을 충족하는지, 놓치는 예외 상황은 없는지 반드시 꼼꼼하게 확인하고 나서 결정
   - 또한, 자신이 생각한 알고리즘을 바탕으로 주어진 예제를 손으로 직접 풀어보는 과정 역시 반드시 수행하는 것이 좋음
